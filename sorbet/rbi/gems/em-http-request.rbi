# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/em-http-request/all/em-http-request.rbi
#
# em-http-request-1.1.7

module EventMachine
end
class EventMachine::IOStreamer
  def initialize(connection, io, opts = nil); end
  def stream_one_chunk; end
  include EventMachine::Deferrable
end
module EventMachine::HTTPMethods
  def delete(options = nil, &blk); end
  def get(options = nil, &blk); end
  def head(options = nil, &blk); end
  def options(options = nil, &blk); end
  def patch(options = nil, &blk); end
  def post(options = nil, &blk); end
  def put(options = nil, &blk); end
end
class EventMachine::HttpStubConnection < EventMachine::Connection
  def certificate_store; end
  def connection_completed; end
  def host; end
  def parent; end
  def parent=(p); end
  def receive_data(data); end
  def ssl_handshake_completed; end
  def ssl_verify_peer(cert_string); end
  def unbind(reason = nil); end
  def verify_peer?; end
  include EventMachine::Deferrable
end
class EventMachine::HttpConnection
  def activate_connection(client); end
  def client; end
  def close(reason = nil); end
  def conn; end
  def conn=(c); end
  def connection_completed; end
  def connopts; end
  def connopts=(arg0); end
  def deferred; end
  def error; end
  def error=(arg0); end
  def finalize_request(c); end
  def initialize; end
  def middleware; end
  def peer; end
  def post_init; end
  def receive_data(data); end
  def redirect(client, new_location); end
  def send_data(data); end
  def setup_request(method, options = nil, c = nil); end
  def start; end
  def stream_data(io, opts = nil); end
  def stream_file_data(filename, args = nil); end
  def unbind(reason = nil); end
  def uri; end
  def uri=(arg0); end
  def use(klass, *args, &block); end
  include EventMachine::Connectify
  include EventMachine::HTTPMethods
  include EventMachine::Socksify
end
class EventMachine::HttpResponseHeader < Hash
  def [](key); end
  def chunked_encoding?; end
  def client_error?; end
  def compressed?; end
  def content_length; end
  def cookie; end
  def etag; end
  def http_reason; end
  def http_reason=(arg0); end
  def http_status; end
  def http_status=(arg0); end
  def http_version; end
  def http_version=(arg0); end
  def informational?; end
  def keepalive?; end
  def last_modified; end
  def location; end
  def raw; end
  def raw=(arg0); end
  def redirection?; end
  def server_error?; end
  def status; end
  def successful?; end
end
module EventMachine::HttpEncoding
  def bytesize(string); end
  def encode_auth(k, v); end
  def encode_cookie(cookie); end
  def encode_field(k, v); end
  def encode_headers(head); end
  def encode_host; end
  def encode_param(k, v); end
  def encode_query(uri, query); end
  def encode_request(method, uri, query, connopts); end
  def escape(s); end
  def form_encode_body(obj); end
  def munge_header_keys(head); end
  def unescape(s); end
end
module EventMachine::HttpStatus
end
class HttpClientOptions
  def body; end
  def compressed; end
  def decoding; end
  def file; end
  def follow_redirect?; end
  def followed; end
  def followed=(arg0); end
  def headers; end
  def host; end
  def initialize(uri, options, method); end
  def keepalive; end
  def method; end
  def no_body?; end
  def pass_cookies; end
  def path; end
  def port; end
  def query; end
  def redirects; end
  def redirects=(arg0); end
  def set_uri(uri, path = nil, query = nil); end
  def ssl?; end
  def uri; end
end
class HttpConnectionOptions
  def bind; end
  def bind_port; end
  def connect_proxy?; end
  def connect_timeout; end
  def host; end
  def http_proxy?; end
  def https=(arg0); end
  def inactivity_timeout; end
  def initialize(uri, options); end
  def port; end
  def proxy; end
  def proxy_from_env; end
  def socks_proxy?; end
  def tls; end
end
class EventMachine::HttpClient
  def build_request; end
  def close(msg = nil); end
  def conn; end
  def conn=(arg0); end
  def connection_completed; end
  def content_charset; end
  def continue?; end
  def cookies; end
  def error; end
  def finished?; end
  def headers(&blk); end
  def initialize(conn, options); end
  def last_effective_url; end
  def normalize_body(body); end
  def on_body_data(data); end
  def on_decoded_body_data(data); end
  def on_error(msg = nil); end
  def on_request_complete; end
  def parse_response_header(header, version, status); end
  def peer; end
  def redirect?; end
  def redirects; end
  def req; end
  def request_body_pending?; end
  def reset!; end
  def response; end
  def response=(arg0); end
  def response_header; end
  def send_request(head, body); end
  def send_request_body; end
  def state; end
  def state=(arg0); end
  def stream(&blk); end
  def unbind(reason = nil); end
  include EventMachine::Deferrable
  include EventMachine::HttpEncoding
  include EventMachine::HttpStatus
end
class EventMachine::HttpClient::CookieJar
  def get(uri); end
  def initialize; end
  def set(string, uri); end
end
class EventMachine::MultiRequest
  def add(name, conn); end
  def check_progress; end
  def finished?; end
  def initialize; end
  def requests; end
  def responses; end
  include EventMachine::Deferrable
end
class EventMachine::HttpRequest
  def self.middleware; end
  def self.new(uri, options = nil); end
  def self.use(klass, *args, &block); end
end
module EventMachine::HttpDecoders
  def self.accepted_encodings; end
  def self.decoder_for_encoding(encoding); end
end
class EventMachine::HttpDecoders::DecoderError < StandardError
end
class EventMachine::HttpDecoders::Base
  def <<(compressed); end
  def decompress(compressed); end
  def finalize!; end
  def finalize; end
  def initialize(&chunk_callback); end
  def receive_decompressed(decompressed); end
  def self.encoding_names; end
end
class EventMachine::HttpDecoders::Deflate < EventMachine::HttpDecoders::Base
  def decompress(compressed); end
  def finalize; end
end
class EventMachine::HttpDecoders::GZipHeader
  def eof?; end
  def extract_stream(compressed); end
  def finished?; end
  def initialize; end
  def read(n, buffer); end
  def readbyte; end
end
class EventMachine::HttpDecoders::GZip < EventMachine::HttpDecoders::Base
  def decompress(compressed); end
  def finalize; end
  def self.encoding_names; end
end
